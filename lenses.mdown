% Lenses
% Alex Mason
% March 2016

# A Refresher
## What are lenses

Lenses allow us to focus in on values within a larger, nested structure.

Focus means, roughly, `get`, `set` and `modify`.

They were born out of the pain of dealing with records in Haskell (more on this later).

## Last month's definition

```haskell
data Lens a b
  = Lens
    { get :: a -> b
    , set :: b -> a -> a
    }


_1 :: Lens (a,b) a
_1 = Lens (\(x,_) -> x)   (\x' (_,y) -> (x',y))

_2 :: Lens (a,b) b
_2 = Lens (\(_,y) -> y)   (\y' (x,_) -> (x,y'))
```

## Functions on lenses

```haskell
-- Lens composition
(>-) :: Lens a b -> Lens b c -> Lens a c
l >- r = Lens (get r . get l)
              -- new :: c
              -- whole :: a
              (\new whole ->
               let inner  = get l whole     -- :: b
                   inner' = set r new inner -- :: b
               in set l inner' whole)

-- A lens focusing on the b in a ((a,b),c)
_1 >- _2 :: Lens ((a,b),c) b

-- Apply a function which modifys `b`s in an `a` focused by a lens
over :: Lens a b -> (b -> b) -> a -> a
over l a = set l (f (get l a))
```

# Concrete example

## Personal Info

```haskell
data Person = Person
  { _firstname :: String
  , _lastname  :: String
  , _initials  :: String
  , _phNums    :: [PNumber]
  , _addresses :: [Address]}

data PNumber = PNumber
  { _name   :: String
  , _type   :: String -- Home, Work, Modile, Fax, etc.
  , _digits :: [Int]
  }

data Address = Address
  { _purpose  :: String     -- Home, Work, Delivery, etc.
  , _unit     :: Maybe Int
  , _streetNo :: Int
  , _street   :: String
  , _suburb   :: String
  , _state    :: String
  , _postCode :: Int
  }
```

<div style="font-size: 50%">
*Some of the choices of data type above are dubious see*

*[Falsehoods programmers believe about addresses](https://www.mjt.me.uk/posts/falsehoods-programmers-believe-about-addresses/)*

*[Falsehoods programmers believe about names](http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)*
</div>

## Person Lenses

```haskell
firstname, lastname, initials :: Lens Person String
firstname = Lens _firstname -- The getter for the _firstname field
                 (\name' person -> person{_firstname = name'})
                 --                      ^^^ Record update syntax
                 --                 The returned value is `person`
                 --                 with all fields not mentioned copied.
lastname = ...

phNums :: Lens Person [PNumber]
phNums = Lens _phNums 
              (\nums' person -> person{_phNums = nums'})



```

# What more could we want?

## Polymorphic update

We know we can apply a function to the focus, but only `b -> b`. What if we want:

```haskell
f :: Int -> String
over :: Lens a b -> (b -> b) -> a -> a -- From before

x :: (Int,Bool)
x = (7,True)

y :: (String,Bool)
y = over f _1 x -- Nope, can't do that
```
  
## Focus on multiple values
If we have a `(a,a)`, we might want a lens `Lens (a,a) a` which gives us access to **both** `a`'s or:

```haskell
-- A lens giving us access to all Strings in an address
-- so we can make them all consistent case
addressStrings :: Lens Address String
...

personStrings :: Lens Person String
...
```

## Partiality

How do we deal with types like `Either`
```haskell
data Either a b = Left a | Right b

_Left :: Lens (Either a b) a
_Left = Lens (\e -> case e of
                Left a -> a
                Right b -> error "Left Expected")
              ... -- setter even harder
```

# Some experiments

## A small refactor


```haskell
data Lens a b
  = Lens
    { get :: a -> b
    , set :: b -> a -> a
    }

-- Becomes

data Lens a b
  = Lens
    { get :: a -> b
    , set :: a -> b -> a -- Arguments flipped
    }
```

## Refactor...

```haskell
data Lens a b
  = Lens
    { get :: a -> b
    , set :: a -> b -> a -- Arguments flipped
    }
-- Becomes this, also isomorphic
data Lens a b
  = Lens
    { getSet :: a -> (b,b -> a)
    }

get :: Lens a b -> a -> b
get (Lens f) a = fst (f a)

set :: Lens a b -> b -> a -> a
set (Lens f) new a = snd (f a) new
```
<span style="font-size: 50%">This is based on the Store Comonad -- it doesn't buy us much. </span>
```haskell
data Store s a = Store (s -> a) s
-- Isomorphic to (s -> a, s)
```

## Polymorphism
```haskell
data Lens a a' b b' = Lens 
  {
  get :: a -> b        -- Same as above, the current focus
  set :: a -> b' -> a' -- A function to replace the focus, polymorphically
  }

-- Now we can write:
_1 :: Lens (a,c) (b,c) a b
_1 = Lens (\(a,c) -> (a,\b -> (b,c)))
```
<small>We can change types!</small>
```haskell
(>->) :: Lens s t a b -> Lens a b x y -> Lens s t x y
(Lens get1 set1) >-> (Lens get2 set2) = 
  Lens (get2 . get1)
       (\s b -> set1 s (set2 b (get1 s) x))
```

<small>But still a pain, not very efficient, and lots of features are still missing.</small>

# Along came Twan
## Along came Twan

Twan van Laarhoven, one of the demigods of the Haskell world, had an idea...*

```haskell
type Lens' a b =
  forall f. Functor f => (b -> f b) -> (a -> f a)
```
<small>* many more people and much research involved</small>

## What the Functor?
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)










...
```

## What the Functor?
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)

newtype Identity a = Identity {runIdentity :: a}




newtype Const x a = Const {runConst :: x} -- a is a phantom type



...
```

## What the Functor?
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)

newtype Identity a = Identity {runIdentity :: a}
instance Functor Identity where
  fmap :: (a -> b) -> (Identity a -> Identity b)


newtype Const x a = Const {runConst :: x} -- a is a phantom type
instance Functor (Const x) where
  fmap :: (a -> b) -> (Const x a -> Const x b)

...
```

## What the Functor?
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)

newtype Identity a = Identity {runIdentity :: a}
instance Functor Identity where
  fmap :: (a -> b) -> (Identity a -> Identity b)
  fmap f (Identity x) = Identity (f x)

newtype Const x a = Const {runConst :: x} -- a is a phantom type
instance Functor (Const x) where
  fmap :: (a -> b) -> (Const x a -> Const x b)

...
```


## What the Functor?
```haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)

newtype Identity a = Identity {runIdentity :: a}
instance Functor Identity where
  fmap :: (a -> b) -> (Identity a -> Identity b)
  fmap f (Identity x) = Identity (f x)

newtype Const x a = Const {runConst :: x} -- a is a phantom type
instance Functor (Const x) where
  fmap :: (a -> b) -> (Const x a -> Const x b)
  fmap _f (Const x) = Const x -- f maps over the 'a' in Const x a,
                              -- and there are no 'a's
```

## What's it buy

```haskell
set :: Lens' a b 
    -> b
    -> a
    -> a
set len b' a =
  ...




type Lens' a b =
  forall f. Functor f => (b -> f b) -> (a -> f a)
...
```


## What's it buy

```haskell
set :: Lens' a b 
    -> b
    -> a
    -> a
set len b' a =
  let f _ = Identity b'    -- b -> Identity b
  ...



type Lens' a b =
  forall f. Functor f => (b -> f b) -> (a -> f a)
                         ----------
```

## What's it buy

```haskell
set :: Lens' a b 
    -> b
    -> a
    -> a
set len b' a =
  let f _ = Identity b'    -- b -> Identity b
      len' = len f         -- a -> Identity a
  ...


type Lens' a b =
  forall f. Functor f => (b -> f b) -> (a -> f a)
                                       ----------
```

## What's it buy

```haskell
set :: Lens' a b 
    -> b
    -> a
    -> a
set len b' a =
  let f _ = Identity b'    -- b -> Identity b
      len' = len f         -- a -> Identity a
  in runIdentity (len' a)  -- a


type Lens' a b =
  forall f. Functor f => (b -> f b) -> (a -> f a)
...
```

## What's it buy

```haskell
set :: Lens' a b 
    -> b
    -> a
    -> a
set len b' a =
  let f _ = Identity b'    -- b -> Identity b
      len' = len f         -- a -> Identity a
  in runIdentity (len' a)  -- a

-- Or
  set len b' a = runIdentity (len (\_ -> Identity b))
```

## Getters looks similar...
```haskell
set :: Lens' a b 
    -> a
    -> a
get len a =
  let f x = Const x     -- b -> Const b b 
                        -- Remember, the second 'b' is a phantom type
      len' = len f      -- a -> Const b a
                        -- Outer Const contains the 'b' we're getting
  in runConst (len' a)  -- a             

-- Or
  get len a = runConst (len (\b -> Const b))

-- Or just
  get len a = runConst (len Const)
```

## Modify looks really familiar

```haskell
modify :: Lens' a b 
    -> (b -> b)
    -> a
    -> a
modify len mod a =
  let f b  = Identity (mod b) -- b -> Identity b
      len' = len f            -- a -> Identity a
  in runIdentity (len' a)     -- a

-- Or
  modify len mod a = runIdentity (len (\b -> Identity (mod b))
```

# Writing lenses
## Writing lenses

```haskell
_1 :: Lens' (a,b) a
_1 f (a,b) = fmap (\a' -> (a,b)) (f a)

_2 :: Lens' (a,b) b
_2 f (a,b) = fmap (\b' -> (a,b)) (f b)

firstname :: Lens' Person String 
          -- a.k.a: Functor f 
          --        => (String -> f String)
          --        -> (Address -> f Address)
firstname fstrstr address = 
  fmap 
    (\fname -> address{_firstname = fname}) -- :: String -> Address
    (fstrstr (_firstname address))          -- :: f String
                                            -- Therefore :: f Address
```

<small>Given a function from `(b -> f b)` for some functor `f`, a lens can give you a function `(a -> f a)`, by giving a `b` to the function, and then placing the new `b` in the old piece of data.
</small>

## Composition

So how do we compose these things?

* Lenses are just functions...
* Can we just... compose them?


## Lets find out
```haskell
(.) :: (a -> b)
    -> (b -> c)
    -> (a -> c)
f . g = \x -> f (g x)

x :: Lens' a b
y :: Lens' b c
```

## Lets find out
```haskell
(.) :: (a -> b) 
    -> (b -> c)
    -> (a -> c)
f . g = \x -> f (g x)

x :: Functor f => (b -> f b) -> (a -> f a)
y :: Functor f => (c -> f c) -> (c -> f c)
```

## Lets find out
```haskell
(.) :: Lens' b c -- a = (c -> f c)
    -> Lens' a b -- b = (b -> f b) --- eh???
    -> Lens' a c -- c = (a -> f a)
f . g = \x -> f (g x)

x :: Functor f => (b -> f b) -> (a -> f a)
y :: Functor f => (c -> f c) -> (b -> f b)
```

## Lets find out
```haskell
(.) :: ((c -> f c) -> (b -> f b)) -- a = (c -> f c)
    -> ((b -> f b) -> (a -> f a)) -- b = (b -> f b)
    -> ((c -> f c) -> (a -> f a)) -- c = (a -> f a)
f . g = \x -> f (g x)

x :: Functor f => (b -> f b) -> (a -> f a)
y :: Functor f => (c -> f c) -> (b -> f b)
```
## Lets find out
```haskell
(.) :: ((c -> f c) -> (b -> f b)) -- a = (c -> f c)
    -> ((b -> f b) -> (a -> f a)) -- b = (b -> f b)
    -> ((c -> f c) -> (a -> f a)) -- c = (a -> f a)
f . g = \x -> f (g x)

x :: Functor f => (b -> f b) -> (a -> f a) -- Lens a b
y :: Functor f => (c -> f c) -> (b -> f b) -- Lens b c

y . x :: Lens a b -- Notice the order is reversed!
```

## How do we use them
```haskell
-- if we have
x :: (Int,(String,Address))
x = (2,("Hello",someAddress))

modify _1 (*3) x                       -- (6,("Hello",someAddress))
modify (_2._1) (map toUpper) x         -- (2,("HELLO",someAddress))
modify (_2._2.firstname) (map toUpper) -- ... the same with with an all uppercase first name
```

---------------

## References

* [Lenses from the ground up](https://speakerdeck.com/markhibberd/lens-from-the-ground-up) Mark Hibberd
